(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* The ?NumberQ in the argument of the function is needed to tell Mathematica to evaluate the function only numerically *)
GapEmpiricalSimulatedMedians[\[Rho]_?NumberQ,\[Bet]_?NumberQ] := Block[{},

TStart1=SessionTime[]; 
If[UseGPU,Construct\[ScriptC]FuncLifeGPU[\[Rho],\[Bet]];,Construct\[ScriptC]FuncLife[\[Rho],\[Bet]];]; (* Constructs interpolated consumption functions *)
TEnd1=SessionTime[];
If[VerboseOutput==True, Print["Step1 Time used (min): ", (TEnd1 - TStart1)/60];];

TStart2=SessionTime[]; 
If[UseGPU,SimulateGPU;,Simulate];                       (* Computes simulated medians *)
TEnd2=SessionTime[];
If[VerboseOutput==True, Print["Step2 Time used (min): ", (TEnd2 - TStart2)/60];];

TStart3=SessionTime[]; 
MomentDifference=Sum[Abs[SCFdata[[indx,3]](SCFdata[[indx,1]]-SimMedian[[SCFdata[[indx,2]]]])],{indx,1,Length[SCFdata]}];
TEnd3=SessionTime[];
If[VerboseOutput==True, Print["Step3 Time used (min): ", (TEnd3 - TStart3)/60];];
If[RecordProgress,AppendTo[TriedTheseGuesses,{{\[Rho],\[Bet]},MomentDifference}];];
Return[MomentDifference];
];


(* JYao: This is to calculate the moment difference for the second round of estimation *)
GapEmpiricalSimulatedMediansSecondRound[\[Rho]_?NumberQ,\[Bet]_?NumberQ] := Block[{},

TStart1=SessionTime[]; 
Construct\[ScriptC]FuncLife[\[Rho],\[Bet]];   (* Constructs interpolated consumption functions *)
TEnd1=SessionTime[];
If[VerboseOutput==True, Print["Step1 Time used (min): ", (TEnd1 - TStart1)/60];];

TStart2=SessionTime[]; 
If[UseGPU,SimulateGPU;,Simulate];                       (* Computes simulated medians *)
TEnd2=SessionTime[];
If[VerboseOutput==True, Print["Step2 Time used (min): ", (TEnd2 - TStart2)/60];];

TStart3=SessionTime[]; 
MomentDifferenceSecondRound=Sum[Abs[SCFdata[[indx,3]]WeightAgeGroup[[SCFdata[[indx,2]]]](SCFdata[[indx,1]]-SimMedian[[SCFdata[[indx,2]]]])],{indx,1,Length[SCFdata]}];
TEnd3=SessionTime[];
If[VerboseOutput==True, Print["Step3 Time used (min): ", (TEnd3 - TStart3)/60];];
If[RecordProgress,AppendTo[TriedTheseGuesses,{{\[Rho],\[Bet]},MomentDifferenceSecondRound}];];
Return[MomentDifferenceSecondRound];
];


(* MNW: A gridsearch method to narrow down the range of \[Rho] and \[Bet]. *)
MNWgridSearch[\[Rho]Lower_,\[Rho]Upper_,\[Bet]Lower_,\[Bet]Upper_,GridPoints_] := Block[{\[Rho]Grid,\[Bet]Grid,j,k,Values,MaxPos,\[Rho]Pos,\[Bet]Pos,\[Rho]LowerOut,\[Rho]UpperOut,\[Bet]LowerOut,\[Bet]UpperOut},
\[Rho]Grid = Range[\[Rho]Lower,\[Rho]Upper,(\[Rho]Upper-\[Rho]Lower)/GridPoints];
\[Bet]Grid = Range[\[Bet]Lower,\[Bet]Upper,(\[Bet]Upper-\[Bet]Lower)/GridPoints];
Values = {};
Do[
    Do[AppendTo[Values,GapEmpiricalSimulatedMedians[\[Rho]Grid[[k]],\[Bet]Grid[[j]]]];
    ,{k,GridPoints+1}];
,{j,GridPoints+1}];
MaxPos = Position[Values,Min[Values]];
\[Rho]Pos = Mod[MaxPos,(GridPoints+1)];
If[\[Rho]Pos==0,\[Rho]Pos = GridPoints+1;];
\[Bet]Pos = (MaxPos-\[Rho]Pos)/(GridPoints+1) + 1;
\[Rho]LowerOut = \[Rho]Grid[[Max[1,\[Rho]Pos-1]]];
\[Rho]UpperOut = \[Rho]Grid[[Min[GridPoints+1,\[Rho]Pos+1]]];
\[Bet]LowerOut = \[Bet]Grid[[Max[1,\[Bet]Pos-1]]];
\[Bet]UpperOut = \[Bet]Grid[[Min[GridPoints+1,\[Bet]Pos+1]]];
Return[{\[Rho]LowerOut,\[Rho]UpperOut,\[Bet]LowerOut,\[Bet]UpperOut}];
];
